#!/usr/bin/env node
/**
 * Open Inventor to VRML 2.0 Converter
 * Converts SGI Open Inventor (.iv) files to VRML 2.0/97 format
 */

const fs = require('fs');
const path = require('path');

function parseInventorFile(content) {
    const shapes = [];
    let currentMaterial = { diffuseColor: [0.8, 0.8, 0.8] };

    // Extract Material blocks
    const materials = [];
    const materialRegex = /Material\s*\{([^}]+)\}/g;
    let materialMatch;
    while ((materialMatch = materialRegex.exec(content)) !== null) {
        const matContent = materialMatch[1];
        const material = {};

        const diffuseMatch = matContent.match(/diffuseColor\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
        if (diffuseMatch) {
            material.diffuseColor = [parseFloat(diffuseMatch[1]), parseFloat(diffuseMatch[2]), parseFloat(diffuseMatch[3])];
        }

        const emissiveMatch = matContent.match(/emissiveColor\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
        if (emissiveMatch) {
            material.emissiveColor = [parseFloat(emissiveMatch[1]), parseFloat(emissiveMatch[2]), parseFloat(emissiveMatch[3])];
        }

        materials.push(material);
    }

    if (materials.length > 0) {
        currentMaterial = materials[0];
    }

    // Find Coordinate3 + IndexedLineSet/IndexedFaceSet combinations
    const coordRegex = /Coordinate3\s*\{\s*point\s*\[\s*([\s\S]*?)\s*\]\s*\}\s*(IndexedLineSet|IndexedFaceSet)\s*\{\s*coordIndex\s*\[\s*([\s\S]*?)\s*\]\s*\}/g;
    let coordMatch;

    while ((coordMatch = coordRegex.exec(content)) !== null) {
        const pointsStr = coordMatch[1];
        const shapeType = coordMatch[2];
        const indicesStr = coordMatch[3];

        const points = [];
        const pointMatches = pointsStr.matchAll(/([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)/g);
        for (const pm of pointMatches) {
            points.push([parseFloat(pm[1]), parseFloat(pm[2]), parseFloat(pm[3])]);
        }

        const indices = [];
        const indexMatches = indicesStr.matchAll(/-?\d+/g);
        for (const im of indexMatches) {
            indices.push(parseInt(im[0]));
        }

        if (points.length > 0 && indices.length > 0) {
            shapes.push({
                type: shapeType,
                points: points,
                indices: indices,
                material: currentMaterial
            });
        }
    }

    // Find Cylinder primitives
    const cylinderRegex = /Cylinder\s*\{([^}]*)\}/g;
    let cylMatch;
    while ((cylMatch = cylinderRegex.exec(content)) !== null) {
        const cylContent = cylMatch[1];
        const radiusMatch = cylContent.match(/radius\s+([\d.]+)/);
        const heightMatch = cylContent.match(/height\s+([\d.]+)/);

        shapes.push({
            type: 'Cylinder',
            radius: radiusMatch ? parseFloat(radiusMatch[1]) : 1,
            height: heightMatch ? parseFloat(heightMatch[1]) : 2,
            material: currentMaterial
        });
    }

    // Find Sphere primitives
    const sphereRegex = /Sphere\s*\{([^}]*)\}/g;
    let sphereMatch;
    while ((sphereMatch = sphereRegex.exec(content)) !== null) {
        const sphereContent = sphereMatch[1];
        const radiusMatch = sphereContent.match(/radius\s+([\d.]+)/);

        shapes.push({
            type: 'Sphere',
            radius: radiusMatch ? parseFloat(radiusMatch[1]) : 1,
            material: currentMaterial
        });
    }

    // Find Cube primitives (Inventor) -> Box (VRML 2.0)
    const cubeRegex = /Cube\s*\{([^}]*)\}/g;
    let cubeMatch;
    while ((cubeMatch = cubeRegex.exec(content)) !== null) {
        const cubeContent = cubeMatch[1];
        const widthMatch = cubeContent.match(/width\s+([\d.]+)/);
        const heightMatch = cubeContent.match(/height\s+([\d.]+)/);
        const depthMatch = cubeContent.match(/depth\s+([\d.]+)/);

        shapes.push({
            type: 'Box',
            width: widthMatch ? parseFloat(widthMatch[1]) : 2,
            height: heightMatch ? parseFloat(heightMatch[1]) : 2,
            depth: depthMatch ? parseFloat(depthMatch[1]) : 2,
            material: currentMaterial
        });
    }

    // Find Cone primitives
    const coneRegex = /Cone\s*\{([^}]*)\}/g;
    let coneMatch;
    while ((coneMatch = coneRegex.exec(content)) !== null) {
        const coneContent = coneMatch[1];
        const radiusMatch = coneContent.match(/bottomRadius\s+([\d.]+)/);
        const heightMatch = coneContent.match(/height\s+([\d.]+)/);

        shapes.push({
            type: 'Cone',
            bottomRadius: radiusMatch ? parseFloat(radiusMatch[1]) : 1,
            height: heightMatch ? parseFloat(heightMatch[1]) : 2,
            material: currentMaterial
        });
    }

    return { shapes, materials };
}

function generateVRML2(parsed) {
    const lines = [];

    lines.push('#VRML V2.0 utf8');
    lines.push('');
    lines.push('# Converted from Open Inventor format');
    lines.push('# Generated by convert-inventor-to-vrml2.js');
    lines.push('');

    // Add navigation info
    lines.push('NavigationInfo {');
    lines.push('  type ["EXAMINE", "ANY"]');
    lines.push('  headlight TRUE');
    lines.push('}');
    lines.push('');

    // Add a default viewpoint
    lines.push('Viewpoint {');
    lines.push('  position 0 0 500');
    lines.push('  description "Default View"');
    lines.push('}');
    lines.push('');

    // Add background
    lines.push('Background {');
    lines.push('  skyColor [0.1 0.1 0.2]');
    lines.push('}');
    lines.push('');

    // Convert each shape
    parsed.shapes.forEach((shape, index) => {
        lines.push(`# Shape ${index + 1}: ${shape.type}`);
        lines.push('Shape {');

        // Appearance
        lines.push('  appearance Appearance {');
        lines.push('    material Material {');
        const color = shape.material.diffuseColor || [0.8, 0.8, 0.8];
        if (shape.type === 'IndexedLineSet') {
            lines.push(`      emissiveColor ${color.join(' ')}`);
        } else {
            lines.push(`      diffuseColor ${color.join(' ')}`);
        }
        lines.push('    }');
        lines.push('  }');

        // Geometry based on type
        if (shape.type === 'IndexedLineSet' || shape.type === 'IndexedFaceSet') {
            lines.push(`  geometry ${shape.type} {`);
            lines.push('    coord Coordinate {');
            lines.push('      point [');
            shape.points.forEach((p, i) => {
                const comma = i < shape.points.length - 1 ? ',' : '';
                lines.push(`        ${p[0]} ${p[1]} ${p[2]}${comma}`);
            });
            lines.push('      ]');
            lines.push('    }');
            lines.push('    coordIndex [');
            const indexRows = [];
            for (let i = 0; i < shape.indices.length; i += 10) {
                const row = shape.indices.slice(i, i + 10);
                indexRows.push('      ' + row.join(', '));
            }
            lines.push(indexRows.join(',\n'));
            lines.push('    ]');
            lines.push('  }');
        } else if (shape.type === 'Cylinder') {
            lines.push(`  geometry Cylinder { radius ${shape.radius} height ${shape.height} }`);
        } else if (shape.type === 'Sphere') {
            lines.push(`  geometry Sphere { radius ${shape.radius} }`);
        } else if (shape.type === 'Box') {
            lines.push(`  geometry Box { size ${shape.width} ${shape.height} ${shape.depth} }`);
        } else if (shape.type === 'Cone') {
            lines.push(`  geometry Cone { bottomRadius ${shape.bottomRadius} height ${shape.height} }`);
        }

        lines.push('}');
        lines.push('');
    });

    return lines.join('\n');
}

// Main execution
const inputFile = process.argv[2] || 'vrml-files/ch.wrl';
const outputFile = process.argv[3] || inputFile.replace('.wrl', '-v2.wrl');

console.log(`Converting: ${inputFile} -> ${outputFile}`);

try {
    const content = fs.readFileSync(inputFile, 'utf8');

    // Check if already VRML 2.0
    if (content.startsWith('#VRML V2.0')) {
        console.log('File is already VRML 2.0 format.');
        process.exit(0);
    }

    // Check if Open Inventor format
    if (!content.startsWith('#Inventor')) {
        console.log('Warning: File does not appear to be Open Inventor format.');
    }

    const parsed = parseInventorFile(content);
    console.log(`Found ${parsed.shapes.length} shapes`);

    if (parsed.shapes.length === 0) {
        console.error('No shapes found in file. Check file format.');
        process.exit(1);
    }

    const vrml2 = generateVRML2(parsed);
    fs.writeFileSync(outputFile, vrml2);

    console.log(`Successfully converted to VRML 2.0: ${outputFile}`);
    console.log(`Output size: ${(vrml2.length / 1024).toFixed(2)} KB`);
} catch (err) {
    console.error('Error:', err.message);
    process.exit(1);
}
