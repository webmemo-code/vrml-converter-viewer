#!/usr/bin/env node
/**
 * Open Inventor to VRML 2.0 Converter
 * Converts SGI Open Inventor (.iv) files to VRML 2.0/97 format
 */

const fs = require('fs');
const path = require('path');

function parseInventorFile(content) {
    const shapes = [];
    let currentMaterial = null;

    // Extract Material blocks
    const materialRegex = /Material\s*\{([^}]+)\}/g;
    const coordinate3Regex = /Coordinate3\s*\{\s*point\s*\[\s*([\s\S]*?)\s*\]\s*\}/g;
    const indexedLineSetRegex = /IndexedLineSet\s*\{\s*coordIndex\s*\[\s*([\s\S]*?)\s*\]\s*\}/g;
    const indexedFaceSetRegex = /IndexedFaceSet\s*\{\s*coordIndex\s*\[\s*([\s\S]*?)\s*\]\s*\}/g;

    // Parse materials
    const materials = [];
    let materialMatch;
    while ((materialMatch = materialRegex.exec(content)) !== null) {
        const matContent = materialMatch[1];
        const material = {};

        const diffuseMatch = matContent.match(/diffuseColor\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
        if (diffuseMatch) {
            material.diffuseColor = [parseFloat(diffuseMatch[1]), parseFloat(diffuseMatch[2]), parseFloat(diffuseMatch[3])];
        }

        const emissiveMatch = matContent.match(/emissiveColor\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
        if (emissiveMatch) {
            material.emissiveColor = [parseFloat(emissiveMatch[1]), parseFloat(emissiveMatch[2]), parseFloat(emissiveMatch[3])];
        }

        materials.push(material);
    }

    currentMaterial = materials[0] || { diffuseColor: [0.8, 0.8, 0.8] };

    // Find all Coordinate3 blocks and their associated IndexedLineSet/IndexedFaceSet
    const separatorRegex = /Separator\s*\{([\s\S]*?)(?=Separator\s*\{|\}[\s]*$)/g;

    // Simple approach: find coordinate blocks and their following index sets
    let coordMatch;
    const coordRegex = /Coordinate3\s*\{\s*point\s*\[\s*([\s\S]*?)\s*\]\s*\}\s*(IndexedLineSet|IndexedFaceSet)\s*\{\s*coordIndex\s*\[\s*([\s\S]*?)\s*\]\s*\}/g;

    while ((coordMatch = coordRegex.exec(content)) !== null) {
        const pointsStr = coordMatch[1];
        const shapeType = coordMatch[2];
        const indicesStr = coordMatch[3];

        // Parse points
        const points = [];
        const pointMatches = pointsStr.matchAll(/([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)/g);
        for (const pm of pointMatches) {
            points.push([parseFloat(pm[1]), parseFloat(pm[2]), parseFloat(pm[3])]);
        }

        // Parse indices
        const indices = [];
        const indexMatches = indicesStr.matchAll(/-?\d+/g);
        for (const im of indexMatches) {
            indices.push(parseInt(im[0]));
        }

        if (points.length > 0 && indices.length > 0) {
            shapes.push({
                type: shapeType,
                points: points,
                indices: indices,
                material: currentMaterial
            });
        }
    }

    return { shapes, materials };
}

function generateVRML2(parsed) {
    const lines = [];

    lines.push('#VRML V2.0 utf8');
    lines.push('');
    lines.push('# Converted from Open Inventor format');
    lines.push('# Generated by convert-inventor-to-vrml2.js');
    lines.push('');

    // Add navigation info
    lines.push('NavigationInfo {');
    lines.push('  type ["EXAMINE", "ANY"]');
    lines.push('  headlight TRUE');
    lines.push('}');
    lines.push('');

    // Add a default viewpoint
    lines.push('Viewpoint {');
    lines.push('  position 0 0 500');
    lines.push('  description "Default View"');
    lines.push('}');
    lines.push('');

    // Add background
    lines.push('Background {');
    lines.push('  skyColor [0.1 0.1 0.2]');
    lines.push('}');
    lines.push('');

    // Convert each shape
    parsed.shapes.forEach((shape, index) => {
        lines.push(`# Shape ${index + 1}: ${shape.type}`);
        lines.push('Shape {');

        // Appearance - for lines, use emissiveColor so they're visible
        lines.push('  appearance Appearance {');
        lines.push('    material Material {');
        const color = shape.material.diffuseColor || [0.8, 0.8, 0.8];
        lines.push(`      emissiveColor ${color.join(' ')}`);
        lines.push('    }');
        lines.push('  }');

        // Geometry
        lines.push('  geometry IndexedLineSet {');

        // Coordinates
        lines.push('    coord Coordinate {');
        lines.push('      point [');
        shape.points.forEach((p, i) => {
            const comma = i < shape.points.length - 1 ? ',' : '';
            lines.push(`        ${p[0]} ${p[1]} ${p[2]}${comma}`);
        });
        lines.push('      ]');
        lines.push('    }');

        // Coord indices
        lines.push('    coordIndex [');
        // Format indices in rows of 10
        const indexRows = [];
        for (let i = 0; i < shape.indices.length; i += 10) {
            const row = shape.indices.slice(i, i + 10);
            indexRows.push('      ' + row.join(', '));
        }
        lines.push(indexRows.join(',\n'));
        lines.push('    ]');

        lines.push('  }');
        lines.push('}');
        lines.push('');
    });

    return lines.join('\n');
}

// Main execution
const inputFile = process.argv[2] || 'vrml-files/ch.wrl';
const outputFile = process.argv[3] || inputFile.replace('.wrl', '-v2.wrl');

console.log(`Converting: ${inputFile} -> ${outputFile}`);

try {
    const content = fs.readFileSync(inputFile, 'utf8');

    // Check if already VRML 2.0
    if (content.startsWith('#VRML V2.0')) {
        console.log('File is already VRML 2.0 format.');
        process.exit(0);
    }

    // Check if Open Inventor format
    if (!content.startsWith('#Inventor')) {
        console.log('Warning: File does not appear to be Open Inventor format.');
    }

    const parsed = parseInventorFile(content);
    console.log(`Found ${parsed.shapes.length} shapes`);

    if (parsed.shapes.length === 0) {
        console.error('No shapes found in file. Check file format.');
        process.exit(1);
    }

    const vrml2 = generateVRML2(parsed);
    fs.writeFileSync(outputFile, vrml2);

    console.log(`Successfully converted to VRML 2.0: ${outputFile}`);
    console.log(`Output size: ${(vrml2.length / 1024).toFixed(2)} KB`);
} catch (err) {
    console.error('Error:', err.message);
    process.exit(1);
}
